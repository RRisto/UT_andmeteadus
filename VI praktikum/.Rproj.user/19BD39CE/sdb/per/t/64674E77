{
    "contents" : "---\ntitle: \"Käsitsi numbrid\"\nauthor: \"Risto Hinno\"\ndate: \"Saturday, May 23, 2015\"\noutput: html_document\n---\n\n##Ülesanne 1 (2 punkti) - andmestikuga tutvumine\n\nVisualiseeri näiteid nii nullide kui ka ühtede seast.\n\nNäpunäited:\n\n- Abiks on ette antud funktsioon plot_digit, mille argumendiks sobib andmestiku üks rida (NB! ilma viimase veeruta)\n\n- Alamjooniste tegemisel on kasuks käsk par(mfrow = c(mitu_rida, mitu_veergu))\n\n- Ääriseid saad muuta par(mar = c(bottom, left, top, right))\n\n```{r, cache=TRUE, warning=FALSE}\n#loeme andmed sisse\nnumbrid=read.csv(\"./data/numbrid.csv\")\n#funktsioon visualiseerimiseks\nplot_digit = function(digit, ...){\n    cols = grey(seq(1, 0, length = 256))\n    image(t(matrix(as.numeric(digit), nrow=28, ncol=28)[28:1, ]), col = cols, ...)\n}\n#määrame mitu joonist ühele ekraanile tahame, ja margini\npar(mfrow=c(2, 5), mar=c(1, 1, 1, 1) + 0.1)\n#plotime 10 plotti\nfor (i in 1:10) {\n    plot_digit(numbrid[i,])\n}\n\n#taastame algsed parameetrid\npar(mfrow=c(1, 1), mar=c(5, 4, 4, 2) + 0.1)\n```\n\nTeine võimalus visualiseerimiseks:\n\n```{r, cache=TRUE, fig.height=1.5, fig.width=1.5, warning=FALSE}\n#kasutame pheatmapi põhjal olevat funktsioon\nlibrary(pheatmap)\n\nplot_digit_pheatmap = function(digit){\n  mat = matrix(as.numeric(digit), nrow=28, ncol=28)\n  pheatmap(mat, cluster_cols=FALSE, cluster_rows=FALSE)\n}\n#plotime, siin ei saa mitut plotti ühele ekraanile\nfor (i in 1:12) {\n    plot_digit_pheatmap(numbrid[i,])\n}\n```\n\nSorteeri andmestiku read selliselt, et üleval oleksid nullid ja all ühed. Visualiseeri kogu andmestikku kasutadaes pheatmap funktsiooni. Kasuta argumente cluster_rows=FALSE, cluster_cols=FALSE.\n\n```{r, cache=TRUE}\nnumbrid_sort <- numbrid[order(numbrid$label),] \npheatmap(numbrid_sort, cluster_rows=FALSE, cluster_cols=FALSE)\n```\n\n- Küsimus: Miks on punased triibud vaheldumisi sinistega?\n\n- Vastus: Kuna iga rida on ühe numbri pikslid (maatriks 28x28), siis nn pildi reaks jagamisel jääb iga numbri vahe tühi ala, mis on sinine. Kuna pilt on \"viilutatud\" reaks, siis hakkab mustei korduma igas viilus (iga 28 piksli järel).\n\n##Ülesanne 2 (4 punkti)\n\nTee andmestikul PCA (kontrolli, et oled eelnevalt andmestikust eemaldanud tunnuse label). PCA tegemiseks kasuta funktsiooni prcomp.Milline on sinu arvates andmestiku “efektiivne dimensionaalsus” praegusel juhul?\n\n```{r, cache=TRUE}\npca = prcomp(numbrid[, -785])\n#koodi ei jooksuta, kuid sellega saab vaadata faktorite olulisust\n#summary(pca)\n```\n\nTee hajuvusdiagramm PC1 vs PC2. Seejärel märgi joonisele, millised punktid kujutavad numbrit 0 ja millised numbrit 1 (võid kasutada värvi või argumenti pch).\n\n```{r, cache=TRUE}\npc1 = pca$x[, 1]\npc2 = pca$x[, 2]\nplot(pc1, pc2, pch=16, col=as.factor(numbrid$label))\n```\n\n- Küsimus: Mida võiks selle joonise põhjal tähistada PC1?\n\n- Vastus: näidata, kas tegu on numbriga 1 või 0\n\nVisualiseeri PCA kaalusid.\n\n```{r, cache=TRUE}\npca_rotate=pca$rotation\nplot_digit_pheatmap(pca_rotate[,1])\n\n```\n\n- Küsimus: Millistel pikslitel on absoluutväärtuselt suured kaalud? Interpreteeri selle abil PC1 tähendust (milliste pikslite intensiivsus peab olema suur ja milliste pikslite intensiivsus madal, et PC1 väärtus oleks võimalikult suur).\n\n- Vastus: keskmistel pikslitel. Keskmiste oma suur (need kus on nr 1) ja madal keskohta ümbritsevate pikslite juures (kus on nr 0).\n\n##Ülesanne 3 (4 punkti)\n\nTee nüüd PCA andmestikul, mis koosneb ainult nullidest. Lisaks tee hajuvusdiagramm PC1 vs PC2.\n\n```{r, cache=TRUE}\nnumbrid_null=subset(numbrid, label==0)\npca_null = prcomp(numbrid_null[, -785])\npc1_null = pca_null$x[, 1]\npc2_null = pca_null$x[, 2]\nplot(pc1_null, pc2_null, pch=16, col=as.factor(numbrid_null$label))\n```\n\n- Küsimus: Kas oskad selle joonise põhjal tõlgendada peakomponente PC1 ja PC2?\n\n- vastus: ei\n\nVali üheksa numbrit tasandi erinevatest nurkadest ja visualiseeri neid funktsiooni plot_digit abil. \n\n```{r, cache=FALSE, warning=FALSE}\n#numbrite leidmiseks kasutasin eelmise graafiku peal seda funktsiooni ja klikkisin\n#punktidele\n#identify(pc1_null, pc2_null, n=9)\n#numbrid mis märkisin:\narvud=c(353, 452, 522, 588, 653, 782, 806, 866, 931)\n\n#plotime\npar(mfrow=c(3, 3), mar=c(1, 1, 1, 1) + 0.1)\n\nfor (i in 1:length(arvud)) {\n    plot_digit(numbrid_null[i,])\n}\n\n# Pärast taasta esialgsed graafilised parameetrid\npar(mfrow=c(1, 1), mar=c(5, 4, 4, 2) + 0.1)\n\n```\n\n- Küsimus: Kuidas tõlgendad selle joonise põhjal peakomponente PC1 ja PC2?\n\n- Vastus: pärius hästi veel öelda ei oska, kuid tundub, et see jagab kuidagi nulle kuju ja paksuse järgi klastritesse.\n\nPunktikeste asemel visualiseeri numbreid.\n\n```{r, cache=TRUE, warning=TRUE}\n#kasutan etteantud funktsiooni\nplot_digit = function(digit, x=NA, y=NA, scale=1, add=FALSE, transparency=FALSE, ...){\n    if(is.na(x)){\n        x = 0\n    }\n    if(is.na(y)){\n        y = 0\n    }\n    \n    x_id = seq(x, x + scale, length=28)\n    y_id = seq(y, y + scale, length=28)\n    \n    if(transparency==TRUE){\n        tmp = as.character(round(seq(0, 0.99, length=256)*100))\n        tmp[nchar(tmp) == 1] = paste(\"0\", tmp[nchar(tmp) == 1], sep=\"\")\n        cols = colorRampPalette(c(\"#FFFFFF\", \"#000000\"))(256)\n        cols = paste(cols, tmp, sep=\"\")\n    }\n    else{\n        cols = grey(seq(1, 0, length = 256))\n    }\n    \n    image(x_id, y_id, t(matrix(as.numeric(digit), nrow=28, ncol=28)[28:1, ]),\n          col = cols, axes=F, asp=1, add=add, ...)\n}\n\n#plotime nullid\nplot(0, 0, type = \"n\", xlim=c(-1500, 1500), ylim=c(-1500, 1000), asp=1)\n#plotin 500, pole rohkem vaja\nfor(i in 1:500){\n    x = pc1_null[i] \n    y = pc2_null[i] \n    \n    plot_digit(numbrid_null[i, -785], x, y, scale=100, add=TRUE, transparency = T)\n}\n\n```\n\n- Küsimus: Kuidas tõlgendad selle joonise põhjal peakomponente PC1 ja PC2?\n\n- Vastus: PC1 näitab, kas 0-d on ovaalsed või ringikujulised, PC2 näitab vist kui püstised 0-d on (või kas on diagonaalsed)\n\nTee samasugune joonis nagu eelmises punktis esialgse nullide ja ühtede andmestiku peal.\n\n```{r, cache=TRUE,warning=FALSE}\nplot(0, 0, type = \"n\", xlim=c(-1500, 1500), ylim=c(-1500, 1000), asp=1)\n\nfor(i in 1:500){\n    x = pc1[i] \n    y = pc2[i] \n    \n    plot_digit(numbrid[i, -785], x, y, scale=100, add=TRUE, transparency = T)\n}\n```\n\n- Küsimus: Kuidas tõlgendad selle joonise põhjal peakomponente PC1 ja PC2?\n\n- Vastus: PC1 näitab, kas tegu on 0 või 1-ga, PC2, kas kriipsud on püsti või \"viltu\"\n\n##Boonusülesanne 1 (2 punkti) - implementeeri PCA\n\nSelle ülesande eesmärk on implementeerida omaenda PCA.\n\n```{r, cache=TRUE, warning=FALSE}\n#teeme pseudoandmed\nx <- c(1,3,6,8,9,10,15,12,17)\ny <- c(10,14,12,17,19,20,20,24,19)\nm <- cbind(x, y)\nplot(m, pch=seq(9))\n\n```\n\nAlguses kasutame prcompi\n\n```{r, cache=TRUE, warning=FALSE}\n\npca_proc <- prcomp(m)\nplot(pca_proc$x, pch=seq(9)) #the pca plot\nplot(pca_proc) #the proportion of variance capture by each PC\n\n```\n\nEt käsitsi teha, siis kige pealt arvutame iga näitaja keskmise ja lahutame igast vaatlusest näitaja keskmise maha (tsentreerime  andmed 0 ümber).\nSeejärel arvutame kovariatsiooni maatrikis vektoritele x1 ja y1 ja plotime need. Need vektorid näitavad variatsiooni suunda andmetes (kui sarnane on cov(x, x) cov(x, y)-le ja kui sarnane on cov(y, y) cov(y, x)-le). X-i kovariatsioon iseendaga on võrdne variatsiooniga (var(x) == cov(x, x)). Kovaratsioonimaatriksi kohta on infot [siin](https://www.youtube.com/watch?v=-08Z-R9kKns).\n\n```{r, cache=TRUE, warning=FALSE}\n#tsentreerime\nx1 <- x - mean(x)\ny1 <- y - mean(y)\nplot(x1, y1, xlim=c(-40, 40), ylim=c(-40, 20))\nm1 <- cbind(x1, y1)\n#kovariatsioon\ncM <- cov(m1)\nlines(x=c(0, cM[1,1]), y=c(0, cM[2,1]), col=\"blue\")\nlines(x=c(0, cM[1,2]), y=c(0, cM[2,2]), col=\"blue\")\n#cov(x, y) ei saa kunagi olla suurem kui cov(x, x), üks joontest graafikul on\n#alati üleval pool diagonaali ning teine allpool. Plotime ka diagonaal (slope=1).\nabline(0, 1, col=\"grey\")\n#kuigi plotitud vektorid näitavad variatsiooni suunda, ei tee nad seda väga kasulikult.\n#Kovariatsioonimaatriksi eigenvektorite leidmisega saame me kirjeldada \n#variatsiooni kahe ristuva ortogoonilise vektoriga, mis näitavad variatsiooni\n#suunda (nende kahe joone asemel, mida algselt kasutame).\neigenVecs <- eigen(cM)$vectors\nlines(x=c(0, eigenVecs[1,1]), y=c(0, eigenVecs[2,1]), col=\"red\")\nlines(x=c(0, eigenVecs[1,2]), y=c(0, eigenVecs[2,2]), col=\"red\")\n#kuna eigenvektorid on ühikvektorid (ehk pikkusega 1), on lihtsam, kui neid\n#visualiseerida, kui palju igaüks neist mõjutab andmeid (korrutame nad vastava\n#eigenväärtusega, mis näitab, kui palju variatsioonist selgitab iga eigenvektor).\neVal1 <- eigen(cM)$values[1]\neVal2 <- eigen(cM)$values[2]\nlines(x=c(0, eVal1*eigenVecs[1,1]), y=c(0, eVal1*eigenVecs[2,1]), col=\"red\")\nlines(x=c(0, eVal2*eigenVecs[1,2]), y=c(0, eVal2*eigenVecs[2,2]), col=\"red\")\n#See maatriks sisaldab eigenvektoreid ning me tahame kuvada nende \n#eigenvektoritena. Praegusel juhul me kasutame mõlemat eigenvektorit, kuid\n#kõrgedimensiooniliste andmete puhul kasutame ainult osa eigenvektoreid \n#(see ongi PCA point).\nrowFeatVec <- t(eigenVecs)\nrowDataAdj <- t(m1)\n#Viimaks kasutame maatriksi korrutamist, et saada punkt iga eigenvekori ja iga\n#originaalse tsentreeritud andmete (m1) vahel. See operatsioon kirjeldab, mil\n#määral igat punkti mõjutab iga eigenvektor. Plotime tulemused. \n#NB! maatriksi korrutamise operaator R-s on %*%\ntransFData <- rowFeatVec %*% rowDataAdj\nfinalData <- rowFeatVec %*% rowDataAdj\nplot(t(finalData), pch=seq(9))\n#lõpuks plotime scree ploti ekvivlendi, mille me tegime üleval \n#(plotime eigenväärtused)\nbarplot(eigen(cM)$values)\n```\n\n##Boonusülesanne 2 (2 punkti) - klassifitseeri numbreid\n\nPaku välja moodus, kuidas pikslite põhjal eristada numbreid 0 ja 1. Leia mitmel juhul sinu meetod prognoosib õigesti, mitmel juhul valesti ja raporteeri täpsus (õigete klassifitseerimiste arv koguarvust). Võiksid täpsuseks saada vähemalt 90%.\n\n```{r, cache=TRUE, warning=FALSE}\n#paneme pc1-d ja labelid kokku\nennustus=data.frame(pc1, numbrid$label)\nnullid=subset(ennustus, pc1<=300)\nsum(nullid$numbrid.label)\n#tundub, et 6  1-te on nullide tabelis, väga täpne. viga on:\nsum(nullid$numbrid.label)/nrow(nullid)*100\n#ühtede puhul on viga\nuhed=subset(ennustus, pc1>300)\nsum(uhed$numbrid.label)/nrow(uhed)*100\n#vigade arv mõlemas\nviga_uhed=nrow(uhed)-sum(uhed$numbrid.label)\nviga_nullid=sum(nullid$numbrid.label)\n#kogu viga\n(viga_uhed+viga_nullid)/nrow(numbrid)*100\n\n```\n\n",
    "created" : 1432408468506.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "485098203",
    "id" : "64674E77",
    "lastKnownWriteTime" : 1432480186,
    "path" : "~/Minu asjad/Statistika, mudelid, excel/R/Andmeteadus_TU/VI praktikum/praktikum6_kasitsi_numbrid.Rmd",
    "project_path" : "praktikum6_kasitsi_numbrid.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}