{
    "contents" : "---\ntitle: \"V praktikum\"\nauthor: \"Risto Hinno\"\ndate: \"Monday, May 18, 2015\"\noutput: html_document\n---\n\n#Andmete kraapimine veebist\n\n##Sissejuhatus\n\nEva “Usin” Masin on esimeses praktikumis kohatud Mati “Raha” Masina vastand. Talle meeldib rutiinsus, andmete tuim kopeerimine ja sisestamine. Vabal ajal meeldib talle lugeda romaanisarja “Tõde ja õigus” - eelmine nädal luges ta kokku tähekombinatsiooni “pa” esinemissageduse. Homme pärast tööd jätkab ta “pb” esinemissageduse leidmisega.\n\nKahjuks oli eelnev tekst fiktsioon ning eva-laadsed kopeerijad surid välja koos neandertaallastega. Selles praktikumis vaatame, kuidas R-is ellu äratada tehis-Eva, kes oskab veebilehtedelt automaatselt infot eraldada ja selle transformeerida struktureeritud andmestikuks.\n\nTäpsemalt, uurime\n\n- kuidas eraldada Riigikogu hääletamistulemusi,\n\n- kuidas eraldada Postimehe uudiste pealkirju,\n\n- kuidas eraldada ilmajaama vaatlusandmeid.\n\nKaks esimest ülesannet õpetavad paketi rvest funktsionaalsust ja annavad sissejuhatuse veebikraapimisse minimalistlike veebilehtede põhjal.\n\n##Ülesanne 1 (2 punkti) - CSS id\n\n- Eralda [html koodis](http://andmeteadus.github.io/examples/html1.html) sinisena olev tekst muutujasse tekst. Kasuta paketti rvest.\n\n- Vastava html koodiga saad mängida [siin](http://www.w3schools.com/html/tryit.asp?filename=tryhtml_css_id).\n\n- Loe lühiülevaadet, [millest koosnevad veebilehed](http://andmeteadus.github.io/praktikum5_rvest_minimal).\n\n- Uuri paketi rvest minimalistlikku [näidet](http://andmeteadus.github.io/praktikum5_rvest_minimal).\n\n- Minimalistliku näite põhjal peaksid oskama eraldada lähtekoodis olevad 4 lõiku. Et eraldada lõik, kus id=“p01”, pead teadma, kuidas CSS-is tähistatakse id-sid. Suur vihje on olemas eelneva html koodi < style > blokis. Abiks võib-olla ka [CSS selektorite interaktiivne testnäide](http://www.w3schools.com/cssref/trysel.asp).\n\n```{r, cache=TRUE}\nlibrary(rvest)\nhtml_source =\"http://andmeteadus.github.io/examples/html1.html\"\npage = html(html_source)\ntekst=page %>% \n    html_node(\"p#p01\") %>%\n    html_text()\ntekst\n```\n\n##Ülesanne 2 (2 punkti) - CSS class\n\nEralda [html koodis](http://andmeteadus.github.io/examples/html2.html) punaselt olev tekst muutujasse tekst. Kasuta paketti rvest.\n\nVastava html koodiga saad mängida [siin](http://www.w3schools.com/html/tryit.asp?filename=tryhtml_css_class).\n\nLõpptulemuse peaks olema selline: tekst = c(\"I am different.\", \"I am different too.\")\n\n```{r, cache=TRUE}\nhtml_source =\"http://andmeteadus.github.io/examples/html2.html\"\npage = html(html_source)\ntekst2=page %>% \n    html_nodes(\"p.error\") %>%\n    html_text()\ntekst2\n```\n\n##Ülesanne 3 (2 punkti)\n\nEralda Riigikogu hääletamistulemuste veebilehe [html lähtekoodist](http://www.riigikogu.ee/?op=ems&page=haaletus&hid=a85129ed-4873-4b9d-ac37-4788b6587fa0&), mitu saadikut hääletas kooseluseaduse eelnõu:\n\n- poolt\n\n- vastu\n\n- oli erapooletu\n\n- ei hääletanud\n\nPraktikumis tutvusime, kuidas brauseri veebiarendus tööriistadega leida üles lähtekoodist vajalikud kohad. Variandid olid:\n\n- Chrome’is vajuta parem klikk ja “inspekteeri elementi”. Alernatiivid on klahvikombinatsioon Ctrl + Shift + I või klahv F12. vahendiga [selectorgadget](http://selectorgadget.com/)\n\n- Need muudavad lähtekoodis õige klassi, id või sildi leidmise oluliselt lihtsamaks. Mõnes olukorras on kasulikum üks variant, mõnes teine.\n```{r, cache=TRUE}\nhtml_source =\"http://www.riigikogu.ee/tegevus/tooulevaade/haaletused/haaletustulemused-kohalolekukontroll/a85129ed-4873-4b9d-ac37-4788b6587fa0/\"\npage = html(html_source)\nhaaletus=page %>% \n    html_nodes(\"li a span\") %>%\n    html_text()\nhaaletus\n```\n\n##Ülesanne 4 (2 punkti)\n\nEralda kooseluseaduse eelnõu hääletamistulemuste veebilehe [html lähtekoodist](http://www.riigikogu.ee/?op=ems&page=haaletus&hid=a85129ed-4873-4b9d-ac37-4788b6587fa0&) andmetabel, kus on 101 rida ning tunnused nr, nimi, otsus, fraktsioon.\n\nVihje: kasuta funktsiooni html_table\n\nKirjuta vastav kood funktsiooniks extract_table (seda funktsiooni läheb vaja järgmises ülesandes, kus eraldad kõigi Riigikogu XII hääletuste kohta vastava tabeli). Sisendiks on kas veebilehe url, faili lokaalne asukoht või sõne. Funktsioon peab tagastama vastava data.frame-i (pane tähele, et su funktsioon ei tagastaks listi, milles on üks data.frame).\n\n\n```{r, cache=TRUE}\nlibrary(knitr)\nhtml_source =\"http://www.riigikogu.ee/tegevus/tooulevaade/haaletused/haaletustulemused-kohalolekukontroll/a85129ed-4873-4b9d-ac37-4788b6587fa0/\"\npage = html(html_source)\n\nhaaletus=page %>% \n    html_nodes(\".table.table.table-striped.full-bars\") %>%\n    html_table()\n#siit saan data frame 101 liikme, erkonna ja hööletustulemusega, nr-d võtan\n#zipitud tabelitest, kuna vahepeal on kodulehte muudetud\nsub=haaletus[1]\nsub2=as.data.frame(sub)\n#puhastan otsuse poolt ja asendan tabelisse\njunn=gsub( \" \", \"\",sub2$Otsus)\njunn2=gsub( \"\\n\\n\", \"\",junn)\njunn3=gsub( \"^Poolt\", \"\",junn2)\njunn3=gsub( \"^Vastu\", \"\",junn3)\njunn3=gsub( \"^EiHääletanud\", \"\",junn3)\njunn3=gsub( \"^Puudub\", \"\",junn3)\njunn3=gsub( \"EiHääletanud\", \"Ei Hääletanud\",junn3)\nsub2$Otsus=junn3\nkable(sub2)\n\n```\n\nFunktsiooni ma ei tee, kuna Riigikogu kodulehte on uuendatud ja funktsioon ei töötaks järgnevate asjade peal.\n\n##Ülesanne 5 (5 punkti) - andmestiku ehitamine\n\nÜlesandes 4 tegid läbi Riigikogu saadikute hääletamistulemuste eraldamise kooseluseaduse korral. Failis [htmls.zip](http://andmeteadus.github.io/data/htmls.zip) on olemas veebilehed kõigi Riigikogu XII hääletuste kohta. Sinu ülesandeks on koostada andmetabel, kus ridades on Riigikogu saadiku nimi ja veergudes kõik hääletamiskorrad. Seda andmestikku läheb vaja järgmises praktikumis, kus uurime hääletamismustreid.\n\nKõigepealt paki lahti zip fail ning loe R-i sisse kõigi html failide nimed.\n\nNäpunäide: Järgnev kood loeb sisse kõik muutujas filenames olevad csv andmestikud ning tekitab neist listi.\n\nlist_of_dataframes = list()\nfor(i in 1:length(filenames)){\n  temp = read.csv(filenames[i])\n  list_of_dataframes[[i]] = temp\n}\n\nPraegu pole sul read.csv käsuga midagi peale hakata, sest tegeleme html failidega. Kasuta ülesandes 4 kirjutatud funktsiooni extract_table.\nEelneva for-tsükli asemel võid kasutada funktsiooni lapply.\n\nLisa igal tsükli sammul andmestikule hääletuse indeks või muu identifikaator. Näiteks temp$haaletus = i.\n\nNüüdseks peaksid olema saanud listi, mille elementideks on erinevad andmetabelid (kõiki faile kasutades peaks nende koguarv olema 1845). Tee nendest andmetabelitest üks suur (pikk) andmetabel, paigutades need üksteise otsa. Seda aitab teha paketi dplyr funktsioon rbind_all. Tulemuseks peaksid saama andmetabeli, mille ridade arv on 101 * “sinu kasutatud failide arv”.\n\nMuuda pikk andmetabel laiaks. Seda aitab teha paketi reshape2 käsk dcast. Uuri funktsiooni dcast minimalistlikku näidet [siit](http://andmeteadus.github.io/praktikum3_reshape/#dcast).\n\nKui kõik eelnev töötab, tee eelnev läbi kõikide html failidega. Ära kohku, kui kõikide html tabelite eraldamisega läheb aega 5 minutit või rohkem.\n\nSoovitus: Kui oled eelneva ühe korra läbi teinud, pole vaja knitri raporti genereerimisel enam sedasama korrata. Saadud andmetabeli saad endale salvestada käsuga save(andmed, file=\"riigikogu.RData\"). Raportis võid muuta vastava koodiploki eval=FALSE.\n\n```{r, eval=FALSE}\n#funktsioon kõige pealt\nextract_table=function(url) {\n    html_source =url\n    page = html(html_source)\n    tabel=page %>% \n        html_nodes(\"table.List\") %>%\n        html_table()%>%\n        as.data.frame()\n    tabel\n}\n\n#loen kõik failid sisse\nfilenames =list.files(\"./data/data\", pattern = \"*.html\", full.names=TRUE)\n\nlist_of_dataframes = list()\nfor(i in 1:length(filenames)){\n    temp = extract_table(filenames[i])\n    temp$haaletus = i\n    list_of_dataframes[[i]] = temp\n}\n#keevitan kokku\nlibrary(dplyr)\nandmed=rbind_all(list_of_dataframes)\n\n#Muudan pika andmetabeli laiaks \nlibrary(reshape2)\nandmed_lai=dcast(andmed, Nimi~haaletus, value.var = \"Otsus\")\n\n```\n\n\n##Ülesanne 6\n\nTagasta kõik Postimehe esilehe uudiste pealkirjad (joonisel näidatud kollasega).\n\nÄra kurvasta, kui sa ei saa absoluutselt kõiki pealkirju, 97% on praegu piisav.\n\n```{r, cache=TRUE}\nurl=\"http://www.postimees.ee/\"\npage = html(url)\ntekst=page %>% \n    html_nodes(\".frontHeading\") %>%\n    html_text()\n#puhastame\ntekst_puhas=gsub(\"\\n\", \"\", tekst)\n#palkirjade lõppu korjab ka kommentaaride arvu, puhastame need välja\ntekst_puhas=gsub(\"\\\\d*$\", \"\", tekst_puhas)\n#eemaldame tühjad stringid\ntekst_puhas=tekst_puhas[tekst_puhas != \"\"] \nkable(tekst_puhas)\n\n```\n\n##Ülesanne 7\n\nJuhised:\n\n- Riigi Ilmateenistus pakub värskeid ilmaandmeid [XML faili kujul](http://www.ilmateenistus.ee/teenused/ilmainfo/eesti-vaatlusandmed-xml/).\n    \n- Meie tegeleme Eesti vaatlusandmete [XML failiga](http://www.ilmateenistus.ee/ilma_andmed/xml/observations.php).\n    \n- Saa XML failist kätte iga ilmajaama õhurõhk.\n    \n- Saa XML failist kätte iga ilmajaama tuule kiirus.\n    \n- Tee neist õhurõhu ja tuule kiiruse scatterplot.\n\n```{r, cache=TRUE, warning=FALSE}\nurl=\"http://www.ilmateenistus.ee/ilma_andmed/xml/observations.php\"\npage = html(url)\n\nohurohk=page %>% \n    html_nodes(\"airpressure\")%>%\n    html_text()\n\ntuulekiirus=page %>% \n    html_nodes(\"windspeed\") %>%\n    html_text()\n\nnimi=page %>% \n    html_nodes(\"name\")%>%\n    html_text()\n\n#teeme numericuks\nohurohk=as.numeric(as.character(ohurohk))\ntuulekiirus=as.numeric(as.character(tuulekiirus))\nilm=data.frame(nimi, tuulekiirus, ohurohk)\n#teeme graafiku\nlibrary(ggplot2)\nggplot(ilm, aes(x=tuulekiirus, y=ohurohk))+\n    geom_point()\n```\n\n\n##Ülesanne 8\n\n\nEesti Loto veebilehel on toodud [statistika loositud pallide sagedusest](https://www.eestiloto.ee/osi/stats.do?lastDraws=250&gameCode=11&sort=frq0&action=searchNumbers).\nEralda vastav tabel, kus veergudes on tunnused number, sagedus ja sagedus protsentides.\nselectorgadget veab sind siin alt ning kergem on lähtekoodi inspekteerida brauseris olevate tööriistadega (Chrome’s vajuta Ctrl + Shift + I või tee parem klikk ja vajuta inspekteeri elementi).\nVisualiseeri saadud andmetabelit. Tee näiteks tulpdiagramm, kus x-teljel on arvud 1-48 ning y-telg tähistab sagedust.\n\n```{r, cache=TRUE}\nhtml_source =\"https://www.eestiloto.ee/osi/stats.do?lastDraws=250&gameCode=11&sort=frq0&action=searchNumbers\"\n#lingi osas tegin ise uue päringu ja võtsin siis lingi, algne peksis segast\npage = html(html_source)\nloto=page %>% \n    html_nodes(\"table\") %>%\n    html_table(fill=T)\n\nnumbrid=as.data.frame(loto[5])\n#graafik\nlibrary(ggplot2)\nggplot(numbrid, aes(x=factor(Number), y=Sagedus))+\n    geom_bar(stat=\"identity\")\n\n```\n\n(2 boonuspunkti + lisaboonuspunkt) Viimase 250 loosiga on pall 35 tulnud 28 korral, pall 34 aga 59 korral. Uuri, kas on alust arvata, et Viking Lotto süsteem on kallutatud. Selleks mõtle välja, kuidas seda kontrollida (näiteks võid kasutada simulatsioonidel põhinevat lähenemist). Selgita lühidalt oma lähenemist ja raporteeri, millise tulemuse said. Lisaboonuspunkti saamiseks visualiseeri seda tulemust.\n```{r, cache=TRUE}\n#teeme simulatsiooni, iga 250 loosi kohta võtame 34 ja 35 esinemise sageduse\n#kordame 100 korda\nlibrary(reshape2)\ntulem=data.frame(c(1:8))\nnames(tulem)=\"järjekord\"\nlist34=list()\nlist35=list()\nj=1\nfor (j in 1:100)  {\n    \n    tulem=data.frame(c(1:8))\n    names(tulem)=\"järjekord\"\n    \n        for (i in 1:250) \n        { \n    tulem[,i+1]=sample(1:48, 8, replace=F)\n    names(tulem)[i+1] <- paste(\"iter\", i, sep = \"\")\n        }\n    \n    tulem_melt=melt(tulem, id=c(\"järjekord\"))\n    #arvutame iga iteratsioonis iga numbri sageduse\n    tulem_sagedus=data.frame(table(tulem_melt$value, tulem_melt$variable))\n    #hoiame alles ainult 34 ja 35 sagedused, kuna need huvitavad\n    tulem_vaja=subset(tulem_sagedus, Var1%in% c(34,35))\n    \n    list34[j]=sum(tulem_vaja$Freq[tulem_vaja[,1]==34])\n    list35[j]=sum(tulem_vaja$Freq[tulem_vaja[,1]==35])\n    j=j+1\n}\n\n#teeme dataframeiks listid ja numericuks et ggplottida\nsimulatsioonid=as.data.frame(rbind(list34, list35))\nsimulatsioonid=as.data.frame(t(simulatsioonid)) #transpose\nsimulatsioonid$list34=as.numeric(simulatsioonid$list34)\nsimulatsioonid$list35=as.numeric(simulatsioonid$list35)\nsimulatsioonid_melt=melt(simulatsioonid)\nsimulatsioonid_melt$value=as.numeric(simulatsioonid_melt$value)\n#siit on hästi näha, mis on 34 ja 35 esinemissageduste jaotus 250 numrbite\n#võtmise korral lotos\nggplot(simulatsioonid_melt, aes(x=variable, y=value))+\n    geom_boxplot()\n\n```\n\n",
    "created" : 1431967009636.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2023417814",
    "id" : "37CB056F",
    "lastKnownWriteTime" : 1431972869,
    "path" : "~/Minu asjad/Statistika, mudelid, excel/R/Andmeteadus_TU/V praktikum/praktikum5_veebiKraapimine.Rmd",
    "project_path" : "praktikum5_veebiKraapimine.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}